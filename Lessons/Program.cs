using System;



namespace Lessons2
{

    //В отличие от абстрактных классов - задача интерфейса ->
    //    - именно только в определении контрактов и того, 
    //    как себя должны вести себя наследники.Без каких либо деталей.
    //        Важным отличием интерфейса от класса, в том числе от абстрактного класса
    //        заключается в том, что интерфейсы могут позволить себе множественное наследование.
    //        Они могут наследоваться между собой, причем один интерфейс может унаследовать 
    //        несколько разных. Также и один определнный класс тоже может унаследовать несколько 
    //        интерфейсов.
    //        Когда, мы говорим о том, что класс унаследован от интерфейса, то правильно говорить то,
    //        что класс реализует интерфейс (т.е класс наследован от интерфейса). 


    //interface -> это не класс, и в нем не может быть конструктора, в отличие от абстрактного класса.
    //Экземпляр интерфйеса также как и экземпляр абстрактного класса мы создать не можем, 
    //    к тому же интерфейс не можжет содержать в себе поля класса(например: int a; -> 
    //это связано с тем, что поведение должно определять поведение и контракт, но не должны содержать 
    //    в себе какой то конкретной реализации
    //)
    //В ООП поведение определяется с помощью метода...


    //данный интерфейс предназначен для того, чтобы определить контракт для класса,
    //который будет получать данные откуда то
    interface IDataProvider
    {
        //Мы описали просто сигнатуру метода, который будет реализован
        //в другом классе который будет реализовывать данный интерфейс
        //п.с в интерфейса все методы по умолчанию имеют модификатор public
        // методы должны быть вызваны на уровне экземпляра
        string GetData();
    }


    //Определяем второй интерфейс для некоторого класса, который будет эти данные обрабатывать

    interface IDataProcessor
    {
        //В классе, в котором будет обрабатывать и реализовывать этот интерфейс
        //должен будет присутствовать метод ProcessData, который в качестве параметра
        //будет принимать объект класса, реализованный интерфейсом DataProvider
        void ProcessData(IDataProvider dataProvider); //--->>>> что здесь происходит???
    }

    //Для того, чтобы реализовывть интерфейс, нам требуется наследоваться от интерфейса
    class ConsoleDataProcessor : IDataProcessor
    {
        //Для устранения ошибки при наследовании интерфейса, нужно реализовать
        //все его компоненты, все методы что там будет, в противном случае код не будет компилироваться
        //(описано в Main)
        public void ProcessData(IDataProvider dataProvider)
        {
            Console.WriteLine(dataProvider.GetData());
        }
    }

    //IDataProvider БУДЕТ РЕАЛИЗОВАНО ЭТОТ ИНТЕРФЕЙС
    class DbDataProvider : IDataProvider
    {
        public string GetData()
        {
            return "Данные из БД";
        }
    }

    class FileDataProvider : IDataProvider
    {
        public string GetData()
        {
            return "Данные из файлы";
        }
    }

    class APIDataProvider : IDataProvider
    {
        public string GetData()
        {
            return "Данные из API";
        }
    }

    class Program
    {
        static void Main(string[] args)
        {

            //Давайте напишем два класса, в котором один класс будет
            //извелкать какие-то данные, а второй класс каким-то образом обрабатывать.
            //В нашем случае это вывод на консоль.

            //Объявляем переменную тип IDataProcessor
            //Это позволяет нам использовать полиморфизм

            //(Продолжение из class ConsoleDataProcessor) Это нужно для того,
            //чтобы в последствии когда мы обращались к ссылке этого такого интерфейса, чтоб мы
            //могли вызвать любой из методов который 
            IDataProcessor A = new ConsoleDataProcessor(); //ЧТО ДЕЛАЕТ ОН????????????????

            //Здесь мы вызываем ProcessData, и когда мы его вызываем, то в качестве параметра
            //передается объект DbDataProvider() -> т.е мы тут же сразу создаем
            A.ProcessData(new DbDataProvider());
            A.ProcessData(new FileDataProvider()); //здесь мы сразу создаем
            A.ProcessData(new APIDataProvider());



        }
    }
}

